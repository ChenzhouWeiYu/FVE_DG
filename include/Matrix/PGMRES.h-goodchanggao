// 文件名：PGMRES.hpp
#pragma once
#include "Matrix/DenseMatrix.h"
#include "Matrix/SparseMatrix.h"
#include "Matrix/LongVector.h"
#include "Matrix/submat.h"

// 模板类实现 PGMRES
template<uInt BlockDim, uInt Max_dims, bool output_flag = false>
class PGMRES;

// Max_dims：控制 Hessenberg 最大维数
// Preconditioner：预条件器类型，接口为 apply(const Vec&, Vec&)
template<uInt BlockDim>
class Preconditioner {
public:
    using Vec = LongVector<BlockDim>;
    virtual Vec apply(const Vec& rhs) = 0;
    virtual ~Preconditioner() = default;
};


template<uInt BlockDim>
class IdentityPreconditioner : public Preconditioner<BlockDim>{
public:
    using Vec = LongVector<BlockDim>;
    IdentityPreconditioner(const BlockSparseMatrix<BlockDim, BlockDim>& A_, uInt DoFs) : A(A_) {     
    }
    Vec apply(const Vec& rhs) override {
        return rhs;
    }
private:
    static constexpr uInt NumBasis = BlockDim/5;
    const BlockSparseMatrix<BlockDim, BlockDim>& A;
};
template<uInt BlockDim>
class DiagPreconditioner : public Preconditioner<BlockDim>{
public:
    using Vec = LongVector<BlockDim>;
    DiagPreconditioner(const BlockSparseMatrix<BlockDim, BlockDim>& A_, uInt DoFs) : A(A_) { 
        DiagVec.resize(DoFs);
        for(uInt brow=0; brow<A.num_block_rows; ++brow){
            for(uInt i=0; i<A.storage.ell_max_per_row; ++i){
                const uInt bcol = A.storage.ell_cols[brow][i];
                if(bcol == brow) {
                    const auto& block = A.storage.ell_blocks[brow][i];
                    for(uInt row = 0; row < BlockDim; row++){
                        DiagVec[brow][row] = 1/block(row,row);
                    }
                }
                
            }
            const uInt start = A.storage.csr_row_ptr[brow];
            const uInt end = A.storage.csr_row_ptr[brow+1];
            
            for(uInt idx = start; idx < end; ++idx) {
                const uInt bcol = A.storage.csr_cols[idx];
                if(bcol == brow) {
                    const auto& block = A.storage.csr_blocks[idx];
                    for(uInt row = 0; row < BlockDim; row++){
                        DiagVec[brow][row] = 1/block(row,row);
                    }
                }
            }
        }
    }
    Vec apply(const Vec& rhs) override {
        return rhs * DiagVec;
    }
private:
    static constexpr uInt NumBasis = BlockDim/5;
    const BlockSparseMatrix<BlockDim, BlockDim>& A;
    Vec DiagVec;
};

template<uInt BlockDim>
class BJacPreconditioner : public Preconditioner<BlockDim>{
public:
    using Vec = LongVector<BlockDim>;
    BJacPreconditioner(const BlockSparseMatrix<BlockDim, BlockDim>& A_, uInt DoFs) : A(A_) { 
        DiagVec.resize(DoFs);
        #pragma omp parallel for schedule(dynamic)
        for(uInt brow=0; brow<A.num_block_rows; ++brow){
            for(uInt i=0; i<A.storage.ell_max_per_row; ++i){
                const uInt bcol = A.storage.ell_cols[brow][i];
                if(bcol == brow) {
                    const auto& block = A.storage.ell_blocks[brow][i];
                    DiagVec[brow] = block.lu();
                }
                
            }
            const uInt start = A.storage.csr_row_ptr[brow];
            const uInt end = A.storage.csr_row_ptr[brow+1];
            
            for(uInt idx = start; idx < end; ++idx) {
                const uInt bcol = A.storage.csr_cols[idx];
                if(bcol == brow) {
                    const auto& block = A.storage.csr_blocks[idx];
                    DiagVec[brow] = block.lu();
                }
            }
        }
    }
    Vec apply(const Vec& rhs) override {
        Vec ret(rhs.size());
        #pragma omp parallel for schedule(dynamic)
        for(uInt brow=0; brow<rhs.size(); ++brow){
            ret[brow] = DiagVec[brow].solve(rhs[brow],DiagVec[brow]);
        }
        return ret;
    }
private:
    static constexpr uInt NumBasis = BlockDim/5;
    const BlockSparseMatrix<BlockDim, BlockDim>& A;
    std::vector<DenseMatrix<BlockDim, BlockDim>> DiagVec;
};

template<uInt BlockDim, uInt InnerMaxIters = 100>
class PhysBlockPreconditioner : public Preconditioner<BlockDim>{
public:
    using Vec = LongVector<BlockDim>;
    PhysBlockPreconditioner(const BlockSparseMatrix<BlockDim, BlockDim>& A_, uInt DoFs) : A(A_) ,
        Arr(get_sub_sparse<NumBasis,1,1,0,0>(A)),
        Arm(get_sub_sparse<NumBasis,1,3,0,1>(A)),
        Are(get_sub_sparse<NumBasis,1,1,0,4>(A)),
        Arr_precond(DiagPreconditioner<1*NumBasis>(Arr,DoFs)),
        Arr_pgmres(PGMRES<1*NumBasis,InnerMaxIters>(Arr,Arr_precond)),
        Amr(get_sub_sparse<NumBasis,3,1,1,0>(A)),
        Amm(get_sub_sparse<NumBasis,3,3,1,1>(A)),
        Ame(get_sub_sparse<NumBasis,3,1,1,4>(A)),   
        Amm_precond(DiagPreconditioner<3*NumBasis>(Amm,DoFs)),
        Amm_pgmres(PGMRES<3*NumBasis,InnerMaxIters>(Amm,Amm_precond)),
        Aer(get_sub_sparse<NumBasis,1,1,4,0>(A)),
        Aem(get_sub_sparse<NumBasis,1,3,4,1>(A)),
        Aee(get_sub_sparse<NumBasis,1,1,4,4>(A)),    
        Aee_precond(DiagPreconditioner<1*NumBasis>(Aee,DoFs)),
        Aee_pgmres(PGMRES<1*NumBasis,InnerMaxIters>(Aee,Aee_precond)),
        Arr_solver(EigenSparseSolver<1*NumBasis, 1*NumBasis>(Arr)),
        Amm_solver(EigenSparseSolver<3*NumBasis, 3*NumBasis>(Amm)),
        Aee_solver(EigenSparseSolver<1*NumBasis, 1*NumBasis>(Aee)){
        
        // printf("DoFs = %d\n",DoFs);
        Ur_tmp.resize(DoFs);
        Um_tmp.resize(DoFs);
        Ue_tmp.resize(DoFs);
        Arr_DiagVec = Arr.get_inv_diag();
        Amm_DiagVec = Amm.get_inv_diag();
        Aee_DiagVec = Aee.get_inv_diag();
    }
    // Vec apply(const Vec& rhs) override {
    //     // printf("%d,%d,%d\n",Ur_tmp.size(),Um_tmp.size(),Ue_tmp.size());
    //     const auto& br = get_sub_vector<NumBasis,1,0>(rhs);
    //     // auto Ur = get_sub_vector<NumBasis,1,0>(res);   
    //     const auto& bm = get_sub_vector<NumBasis,3,1>(rhs);
    //     // auto Um = get_sub_vector<NumBasis,3,1>(res);
    //     const auto& be = get_sub_vector<NumBasis,1,4>(rhs);
    //     // auto Ue = get_sub_vector<NumBasis,1,4>(res);

    //     LongVector<BlockDim> Urme_tmp = rhs;

    //     // Arr_pgmres.solve(Ur_tmp, br - Arm.multiply(Um) - Are.multiply(Ue), 100, 1e-12);
    //     // Arr_pgmres.solve(Ur_tmp, br, 100, 1e-12);
    //     // set_sub_vector<NumBasis,1,0>(Ur_tmp,Urme_tmp);
    //     Ur_tmp.fill_scalar(0.0);
    //     // Arr_pgmres.solve(Ur_tmp, br, 100, 1e-4);
    //     Arr_solver.set_rhs(br);
    //     Ur_tmp = Arr_solver.SparseLU(Ur_tmp);
    //     // Ur_tmp = br * Arr_DiagVec;
    //     set_sub_vector<NumBasis,1,0>(Ur_tmp,Urme_tmp);
        
    //     //Amm_pgmres.solve(Um_tmp, bm - Amr.multiply(Ur) - Ame.multiply(Ue), 100, 1e-12);
    //     Um_tmp.fill_scalar(0.0);
    //     // Amm_pgmres.solve(Um_tmp, bm, 100, 1e-4);
    //     Amm_solver.set_rhs(bm);
    //     Um_tmp = Amm_solver.SparseLU(Um_tmp);
        
    //     // Um_tmp = bm * Amm_DiagVec;
    //     set_sub_vector<NumBasis,3,1>(Um_tmp,Urme_tmp);
        
    //     // Aee_pgmres.solve(Ue_tmp, be - Aer.multiply(Ur) - Aem.multiply(Um), 100, 1e-12);
    //     // Aee_pgmres.solve(Ue_tmp, be, 100, 1e-12);
    //     // set_sub_vector<NumBasis,1,4>(Ue_tmp,Urme_tmp);
    //     Ue_tmp.fill_scalar(0.0);
    //     // Arr_pgmres.solve(Ur_tmp, br, 100, 1e-4);
    //     Aee_solver.set_rhs(be);
    //     Ue_tmp = Aee_solver.SparseLU(Ue_tmp);
    //     // Ue_tmp = be * Aee_DiagVec;
    //     set_sub_vector<NumBasis,1,4>(Ue_tmp,Urme_tmp);

    //     return Urme_tmp;
    // }

    ////块对角 Block Jacobi 预条件
    Vec apply(const Vec& rhs) override {
        
        const auto& br = get_sub_vector<NumBasis,1,0>(rhs);
        
        const auto& bm = get_sub_vector<NumBasis,3,1>(rhs);
       
        const auto& be = get_sub_vector<NumBasis,1,4>(rhs);      

        LongVector<BlockDim> Urme_tmp = rhs;
       
        Ur_tmp.fill_scalar(0.0);
       
        Arr_solver.set_rhs(br);
        Ur_tmp = Arr_solver.SparseLU(Ur_tmp);
        
        set_sub_vector<NumBasis,1,0>(Ur_tmp,Urme_tmp);        
        
        Um_tmp.fill_scalar(0.0);
       
        Amm_solver.set_rhs(bm);
        Um_tmp = Amm_solver.SparseLU(Um_tmp);
        
        set_sub_vector<NumBasis,3,1>(Um_tmp,Urme_tmp);       
        
        Ue_tmp.fill_scalar(0.0);        
        Aee_solver.set_rhs(be);
        Ue_tmp = Aee_solver.SparseLU(Ue_tmp);       
        set_sub_vector<NumBasis,1,4>(Ue_tmp,Urme_tmp);
        return Urme_tmp;
    }

    ////点对角 Jacobi 预条件

// Vec apply(const Vec& rhs) override {

//     const auto& br = get_sub_vector<NumBasis,1,0>(rhs);
//     const auto& bm = get_sub_vector<NumBasis,3,1>(rhs);
//     const auto& be = get_sub_vector<NumBasis,1,4>(rhs);

//     LongVector<BlockDim> Urme_tmp = rhs;
//     // === 密度块 ===
//     Ur_tmp.fill_scalar(0.0);
//     // Arr_solver.set_rhs(br);
//     // Ur_tmp = Arr_solver.SparseLU(Ur_tmp);
//     Ur_tmp = br * Arr_DiagVec;
//     set_sub_vector<NumBasis,1,0>(Ur_tmp, Urme_tmp);
//     // === 动量块 ===
//     Um_tmp.fill_scalar(0.0);
//     // Amm_solver.set_rhs(bm);
//     // Um_tmp = Amm_solver.SparseLU(Um_tmp);
//     Um_tmp = bm * Amm_DiagVec;
//     set_sub_vector<NumBasis,3,1>(Um_tmp, Urme_tmp);
//     // === 能量块 ===
//     Ue_tmp.fill_scalar(0.0);
//     // Aee_solver.set_rhs(be);
//     // Ue_tmp = Aee_solver.SparseLU(Ue_tmp);
//     Ue_tmp = be * Aee_DiagVec;
//     set_sub_vector<NumBasis,1,4>(Ue_tmp, Urme_tmp);
//     return Urme_tmp;
// }
  //下面要计算文档中 M_1^{-1} ，修改apply 函数
// Vec apply(const Vec& rhs) override {
//     const auto& br = get_sub_vector<NumBasis,1,0>(rhs);
//     const auto& bm = get_sub_vector<NumBasis,3,1>(rhs);
//     const auto& be = get_sub_vector<NumBasis,1,4>(rhs);

//     LongVector<BlockDim> Urme_tmp = rhs;

//     // --- M^{-1}_1: rho block = identity ---
//     Ur_tmp = br;
//     set_sub_vector<NumBasis,1,0>(Ur_tmp, Urme_tmp);

//     // --- M^{-1}_1: momentum block = diag preconditioner ---
//     Um_tmp = bm * Amm_DiagVec;
//     set_sub_vector<NumBasis,3,1>(Um_tmp, Urme_tmp);

//     // --- M^{-1}_1: energy block = blockdiag preconditioner ---
//     // Option A: PG-MRES
//     // Aee_pgmres.solve(Ue_tmp, be, 100, 1e-8);

//     // Option B: SparseLU
//     Ue_tmp = Aee_solver.SparseLU(be);

//     set_sub_vector<NumBasis,1,4>(Ue_tmp, Urme_tmp);

//     return Urme_tmp;
// }
//////////////////////////////////////////////
//下面要计算文档中 M_2^{-1} ，修改apply 函数
// Vec apply(const Vec& rhs) override {
//     const auto& br = get_sub_vector<NumBasis,1,0>(rhs);
//     const auto& bm = get_sub_vector<NumBasis,3,1>(rhs);
//     const auto& be = get_sub_vector<NumBasis,1,4>(rhs);

//     LongVector<BlockDim> Urme_tmp = rhs;

//     // --- M^{-1}_2: rho block = diag preconditioner ---
//     Ur_tmp = br * Arr_DiagVec;
//     set_sub_vector<NumBasis,1,0>(Ur_tmp, Urme_tmp);

//     // --- M^{-1}_2: momentum block = identity ---
//     Um_tmp = bm;
//     set_sub_vector<NumBasis,3,1>(Um_tmp, Urme_tmp);

//     // --- M^{-1}_2: energy block = blockdiag preconditioner ---
//     // Option A: PG-MRES
//     // Aee_pgmres.solve(Ue_tmp, be, 100, 1e-8);

//     // Option B: SparseLU (recommended)
//     Ue_tmp = Aee_solver.SparseLU(be);

//     set_sub_vector<NumBasis,1,4>(Ue_tmp, Urme_tmp);

//     return Urme_tmp;
// }
//////////////////////////////////////////////
//下面要计算文档中 M_3^{-1} ，修改apply 函数
// Vec apply(const Vec& rhs) override {
//     const auto& br = get_sub_vector<NumBasis,1,0>(rhs);
//     const auto& bm = get_sub_vector<NumBasis,3,1>(rhs);
//     const auto& be = get_sub_vector<NumBasis,1,4>(rhs);

//     LongVector<BlockDim> Urme_tmp = rhs;

//     // --- M^{-1}_3: rho block = blockJacobi preconditioner ---
//     // Option A: PG-MRES
//     // Arr_pgmres.solve(Ur_tmp, br, 100, 1e-8);

//     // Option B: SparseLU (recommended)
//     Ur_tmp = Arr_solver.SparseLU(br);

//     set_sub_vector<NumBasis,1,0>(Ur_tmp, Urme_tmp);

//     // --- M^{-1}_3: momentum block = diag preconditioner ---
//     Um_tmp = bm * Amm_DiagVec;
//     set_sub_vector<NumBasis,3,1>(Um_tmp, Urme_tmp);

//     // --- M^{-1}_3: energy block = identity ---
//     Ue_tmp = be;
//     set_sub_vector<NumBasis,1,4>(Ue_tmp, Urme_tmp);

//     return Urme_tmp;
// }
////////////////////////////////
//下面要计算文档中 M_4^{-1} ，修改apply 函数
// Vec apply(const Vec& rhs) override {
//     const auto& br = get_sub_vector<NumBasis,1,0>(rhs);
//     const auto& bm = get_sub_vector<NumBasis,3,1>(rhs);
//     const auto& be = get_sub_vector<NumBasis,1,4>(rhs);

//     LongVector<BlockDim> Urme_tmp = rhs;

//     // --- M^{-1}_4: rho block = blockJacobi ---
//     // Option A:
//     // Arr_pgmres.solve(Ur_tmp, br, 100, 1e-8);
//     // Option B (recommended):
//     Ur_tmp = Arr_solver.SparseLU(br);
//     set_sub_vector<NumBasis,1,0>(Ur_tmp, Urme_tmp);

//     // --- M^{-1}_4: momentum block = blockJacobi ---
//     // Option A:
//     // Amm_pgmres.solve(Um_tmp, bm, 100, 1e-8);
//     // Option B (recommended):
//     Um_tmp = Amm_solver.SparseLU(bm);
//     set_sub_vector<NumBasis,3,1>(Um_tmp, Urme_tmp);

//     // --- M^{-1}_4: energy block = scalar diagonal preconditioner ---
//     Ue_tmp = be * Aee_DiagVec;
//     set_sub_vector<NumBasis,1,4>(Ue_tmp, Urme_tmp);

//     return Urme_tmp;
// }
// ////////////////////////////////////M_5^{-1} ，
// Vec apply(const Vec& rhs) override {
//     const auto& br = get_sub_vector<NumBasis,1,0>(rhs);
//     const auto& bm = get_sub_vector<NumBasis,3,1>(rhs);
//     const auto& be = get_sub_vector<NumBasis,1,4>(rhs);

//     LongVector<BlockDim> Urme_tmp = rhs;

//     // rho 用 Diag
//     Ur_tmp.fill_scalar(0.0);
//     Ur_tmp = br * Arr_DiagVec;
//     set_sub_vector<NumBasis,1,0>(Ur_tmp, Urme_tmp);

//     // m 用 BlockSolver
//     Um_tmp.fill_scalar(0.0);
//     Amm_solver.set_rhs(bm);
//     Um_tmp = Amm_solver.SparseLU(Um_tmp);
//     set_sub_vector<NumBasis,3,1>(Um_tmp, Urme_tmp);

//     // E 用 Diag
//     Ue_tmp.fill_scalar(0.0);
//     Ue_tmp = be * Aee_DiagVec;
//     set_sub_vector<NumBasis,1,4>(Ue_tmp, Urme_tmp);

//     return Urme_tmp;
// }




private:
    static constexpr uInt NumBasis = BlockDim/5;
    const BlockSparseMatrix<BlockDim, BlockDim>& A;
    BlockSparseMatrix<1*NumBasis, 1*NumBasis> Arr;
    BlockSparseMatrix<1*NumBasis, 3*NumBasis> Arm;
    BlockSparseMatrix<1*NumBasis, 1*NumBasis> Are;
    EigenSparseSolver<1*NumBasis, 1*NumBasis> Arr_solver;
    DiagPreconditioner<1*NumBasis> Arr_precond;
    PGMRES<1*NumBasis,InnerMaxIters> Arr_pgmres;
    LongVector<1*NumBasis> Ur_tmp;  
    LongVector<1*NumBasis> Arr_DiagVec;

    BlockSparseMatrix<3*NumBasis, 1*NumBasis> Amr;
    BlockSparseMatrix<3*NumBasis, 3*NumBasis> Amm;
    BlockSparseMatrix<3*NumBasis, 1*NumBasis> Ame;
    EigenSparseSolver<3*NumBasis, 3*NumBasis> Amm_solver;
    DiagPreconditioner<3*NumBasis> Amm_precond;
    PGMRES<3*NumBasis,InnerMaxIters> Amm_pgmres;
    LongVector<3*NumBasis> Um_tmp;  
    LongVector<3*NumBasis> Amm_DiagVec;

    BlockSparseMatrix<1*NumBasis, 1*NumBasis> Aer;
    BlockSparseMatrix<1*NumBasis, 3*NumBasis> Aem;
    BlockSparseMatrix<1*NumBasis, 1*NumBasis> Aee;
    EigenSparseSolver<1*NumBasis, 1*NumBasis> Aee_solver;
    DiagPreconditioner<1*NumBasis> Aee_precond;
    PGMRES<1*NumBasis,InnerMaxIters> Aee_pgmres;
    LongVector<1*NumBasis> Ue_tmp;  
    LongVector<1*NumBasis> Aee_DiagVec;
};


template<uInt BlockDim, uInt Max_dims, bool output_flag>
class PGMRES {
public:
    // using Vec = DenseMatrix<BlockDim, 1>;
    using Vec = LongVector<BlockDim>;

    PGMRES(const BlockSparseMatrix<BlockDim, BlockDim>& A_, Preconditioner<BlockDim>& M_)
        : A(A_), M(M_) {}

    // 主迭代函数
    std::tuple<uInt,Scalar> solve(Vec& x, const Vec& b, uInt max_iter, Scalar tol) {
        std::array<Vec, Max_dims + 1> V{};       // 正交基 V_0, ..., V_m
        std::array<Vec, Max_dims> Z{};           // 预条件后向量 z_j = M^{-1} v_j
        DenseMatrix<Max_dims + 1, Max_dims> H{}; // Hessenberg 矩阵
        DenseMatrix<Max_dims + 1, 1> g{};         // g = beta * e1

        // print("spmv 前");
        Vec r0 = b - A.multiply(x);
        // print("spmv后，norm前");
        Scalar beta = r0.norm();
        // print("初始残差 r_0 = " + std::to_string(beta));
        if (beta < tol) return {0, beta};

        V[0] = r0 / beta;
        g(0, 0) = beta;

        // Givens 旋转参数
        std::array<Scalar, Max_dims> cs{}, sn{};

        for (uInt j = 0; j < max_iter && j < Max_dims; ++j) {
            // 预条件：z_j = M^{-1} v_j
            // print("预条件前");
            Z[j] = M.apply(V[j]);
            if constexpr (output_flag){
                printf("iter = %ld ,  ||Az-v|| residual = %le\n",j, (A.multiply(Z[j])-V[j]).norm()/V[j].norm());
            }

            // print("预条件后");

            // w = A z_j
            Vec w = A.multiply(Z[j]);
            // print("预条件的残差向量");

            // Arnoldi 正交化
            for (uInt i = 0; i <= j; ++i) {
                H(i, j) = V[i].dot(w);
                w -= H(i, j) * V[i];
            }
            H(j + 1, j) = w.norm();
            // print("H矩阵");

            if (H(j + 1, j) < 1e-14) break; // 说明基生成失败（已收敛）

            V[j + 1] = w / H(j + 1, j);
            
            // print("开始 GIvens 旋转");
            // Apply Givens rotations to new column H(:,j)
            
            for (uInt i = 0; i < j; ++i)
                apply_givens(H(i, j), H(i + 1, j), cs[i], sn[i]);

            // Create new Givens rotation
            generate_givens(H(j, j), H(j + 1, j), cs[j], sn[j]);
            apply_givens(H(j, j), H(j + 1, j), cs[j], sn[j]);
            apply_givens(g(j, 0), g(j + 1, 0), cs[j], sn[j]);
            if constexpr (output_flag){
                printf("iter = %ld ,   residual = %le\n",j, g(j + 1, 0)/beta);
            }
            // print("Givens旋转完");
            // Check residual
            if (std::abs(g(j + 1, 0))/beta < tol) {
                reconstruct_solution(x, Z, H, g, j + 1);
                return {j,std::abs(g(j + 1, 0))/beta};
            }
        }

        reconstruct_solution(x, Z, H, g, max_iter);
        uInt real_iter = std::min(max_iter,Max_dims);
        return {real_iter,std::abs(g(real_iter, 0))/beta};
    }

private:
    const BlockSparseMatrix<BlockDim, BlockDim>& A;
    Preconditioner<BlockDim>& M;

    // 生成 Givens 旋转
    void generate_givens(Scalar a, Scalar b, Scalar& c, Scalar& s) {
        if (std::abs(b) < 1e-14) {
            c = 1.0; s = 0.0;
        } else if (std::abs(b) > std::abs(a)) {
            Scalar t = -a / b;
            s = 1.0 / std::sqrt(1 + t * t);
            c = s * t;
        } else {
            Scalar t = -b / a;
            c = 1.0 / std::sqrt(1 + t * t);
            s = c * t;
        }
    }

    // 应用 Givens 旋转到 (a,b)
    void apply_givens(Scalar& a, Scalar& b, Scalar c, Scalar s) {
        Scalar temp = c * a - s * b;
        b = s * a + c * b;
        a = temp;
    }

    // 解最小二乘问题并更新解
    void reconstruct_solution(Vec& x, const std::array<Vec, Max_dims>& Z,
                              const DenseMatrix<Max_dims + 1, Max_dims>& H,
                              const DenseMatrix<Max_dims + 1, 1>& g,
                              uInt k) {
        DenseMatrix<Max_dims, 1> y{};
        // 回代解 y: H(0:k,0:k) * y = g(0:k)
        for (int i = k - 1; i >= 0; --i) {
            y(i, 0) = g(i, 0);
            for (uInt j = i + 1; j < k; ++j)
                y(i, 0) -= H(i, j) * y(j, 0);
            y(i, 0) /= H(i, i);
        }

        for (uInt i = 0; i < k; ++i)
            x += Z[i] * y(i, 0);
    }
};
