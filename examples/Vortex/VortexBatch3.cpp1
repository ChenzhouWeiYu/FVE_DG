#include "base/Type.h"
#include "Mesh/Mesh.h"
#include "Matrix/Matrix.h"
#include "submat.h"
#include "DG/DG_Basis/DG_Basis.h"
#include "DG/DG_Schemes/ImplicitConvection.h"
#include "EigenSolver/EigenSparseSolver.h"

string sol_filename(uInt Order, uInt Time, uInt Nmesh)
{
    return "./Order_" + std::to_string(Order) + "/solution/T_" + std::to_string(Time) + "_N_" + std::to_string(Nmesh) + ".txt";
}

#include "problem.h"
ComputingMesh create_mesh(uInt N)
{
    GeneralMesh mesh = OrthHexMesh({0, 0, 0}, {10, 10, 10.0 / N}, {N, N, 1});
    mesh.split_hex5_scan();
    mesh.rebuild_cell_topology();
    mesh.validate_mesh();
    ComputingMesh cmesh(mesh);
    cmesh.m_boundaryTypes.resize(cmesh.m_faces.size());
    for (uInt faceId = 0; faceId < cmesh.m_faces.size(); faceId++)
    {
        if (cmesh.m_faces[faceId].m_neighbor_cells[1] == uInt(-1))
        {
            const auto &face = cmesh.m_faces[faceId];
            if (std::abs(face.m_normal[2]) > 0.5)
                cmesh.m_boundaryTypes[faceId] = BoundaryType::Pseudo3DZ;
            else
                cmesh.m_boundaryTypes[faceId] = BoundaryType::Dirichlet;
        }
    }
    return cmesh;
}

template <uInt Order>
void Run(uInt N)
{
    auto chrono_start = std::chrono::steady_clock::now();
    auto chrone_clock = [&]()
    { return std::chrono::duration<double>(std::chrono::steady_clock::now() - chrono_start).count(); };
    auto logging = [&](std::string ss)
    { debug("Time  " + std::to_string(chrone_clock()) + "  \tsec      " + ss); };
    debug("Start   " + std::to_string(chrone_clock()));

    const auto &cmesh = create_mesh(N);
    logging("Split Hex Mesh to Tet");

    using Basis = DGBasisEvaluator<Order>;
    using QuadC = typename AutoQuadSelector<Basis::OrderBasis, GaussLegendreTet::Auto>::type;
    constexpr uInt DoFs = 5 * Basis::NumBasis;

    LongVector<DoFs> x(cmesh.m_cells.size());

#pragma omp parallel for schedule(dynamic)
    for (uInt cellId = 0; cellId < cmesh.m_cells.size(); cellId++)
    {
        const auto &cell = cmesh.m_cells[cellId];
        const auto &rhoU_coef = Basis::func2coef([&](vector3f Xi) -> DenseMatrix<5, 1>
                                                 { return {rho_Xi(cell, Xi), rhou_Xi(cell, Xi), rhov_Xi(cell, Xi), rhow_Xi(cell, Xi), rhoe_Xi(cell, Xi)}; });
        for (uInt k = 0; k < Basis::NumBasis; k++)
        {
            MatrixView<DoFs, 1, 5, 1>(x[cellId], 5 * k, 0) = rhoU_coef[k];
        }
    }

    logging("Set Init Value");

    ImplicitConvection<Basis::OrderBasis> convection;

    LongVector<DoFs> mass(x.size());
    for (uInt cellId = 0; cellId < cmesh.m_cells.size(); cellId++)
    {
        DenseMatrix<DoFs, DoFs> mass_matrix;
        for (uInt xgId = 0; xgId < QuadC::num_points; ++xgId)
        {
            const auto &p = QuadC::points[xgId];
            auto phi = Basis::eval_all(p[0], p[1], p[2]);
            for (uInt i = 0; i < Basis::NumBasis; ++i)
            {
                for (uInt k = 0; k < 5; ++k)
                {
                    mass[cellId](5 * i + k, 0) += phi[i] * phi[i] *
                                                  QuadC::weights[xgId] * cmesh.m_cells[cellId].compute_jacobian_det();
                }
            }
        }
    }

    print(std::array<std::string, 8>{"#       time", "rel.err  rho",
                                     "rel.err  u", "rel.err  v", "rel.err  w",
                                     "rel.err  e", "rel.err coef", "cpu time"});

    for (uInt kkkk = 0; kkkk < 1; kkkk++)
    {
        Scalar Dt = 0.5;
        Scalar max_dt = Dt * std::pow((5.0 / N), (Order + 1));
        Scalar dt = max_dt;
        Scalar sub_t = 0;
        do
        {
            dt = std::min(max_dt, Dt - sub_t);
            sub_t += dt;
            LongVector<DoFs> dx = x;
            for (uInt picard_iter = 0; picard_iter < 100; picard_iter++)
            {
                LongVector<DoFs> rhs(x.size());
                BlockSparseMatrix<DoFs, DoFs> sparse_mat;

                convection.assemble(cmesh, dx, Dt * (kkkk) + sub_t + 0.5 * dt,
                                    sparse_mat, rhs);

                for (uInt cellId = 0; cellId < cmesh.m_cells.size(); cellId++)
                {
                    const auto &diag = DenseMatrix<DoFs, DoFs>::Diag(mass[cellId] / dt);
                    sparse_mat.add_block(cellId, cellId, diag);
                    rhs[cellId] += diag.multiply(x[cellId]);
                }

                sparse_mat.finalize();

                auto Aee = get_sub_sparse<Basis::NumBasis, 1, 4, 1, 4>(sparse_mat);
                auto be = get_sub_vector<Basis::NumBasis, 1, 4>(rhs);
                auto Ue = get_sub_vector<Basis::NumBasis, 1, 4>(dx);

                auto Arm = get_sub_sparse<Basis::NumBasis, 1, 1, 1, 1>(sparse_mat);
                auto br = get_sub_vector<Basis::NumBasis, 1, 1>(rhs);
                auto Um = get_sub_vector<Basis::NumBasis, 1, 1>(dx);
                LongVector<Basis::NumBasis> ArmUm = Arm.multiply(Um);

                logging("||br|| = " + std::to_string(std::sqrt(br.dot(br))));
                logging("||Arm*Um|| = " + std::to_string(std::sqrt(ArmUm.dot(ArmUm))));

                auto sol_Aee = [&](LongVector<DoFs> &u_full)
                {
                    EigenSparseSolver<Basis::NumBasis, Basis::NumBasis> solver(Aee, be);
                    auto Ue_new = solver.SparseLU(Ue);
                    set_sub_vector<Basis::NumBasis, 1, 4>(Ue_new, u_full);
                };

                sol_Aee(dx);

                EigenSparseSolver<DoFs, DoFs> solver(sparse_mat, rhs);
                LongVector<DoFs> ddx = solver.BiCGSTAB(dx);
                auto delta_x = ddx - dx;
                dx = ddx;
                Scalar delta = std::sqrt(delta_x.dot(delta_x));
                logging("Picard iter " + std::to_string(picard_iter) + "  delta = " + std::to_string(delta));
                if (delta < 1e-10)
                    break;
            }
            x = dx;
            logging("Iter  " + std::to_string(kkkk + 1) + " \tSub TimeStep \t" + std::to_string(sub_t));
        } while (sub_t < Dt);
    }
}

int main(int argc, char **argv)
{
    omp_set_num_threads(get_phy_cpu());
    Eigen::setNbThreads(get_phy_cpu());
    int order = std::stoi(argv[1]);
    int meshN = std::stoi(argv[2]);
    if (order == 1)
        Run<1>(meshN);
    if (order == 2)
        Run<2>(meshN);
    if (order == 3)
        Run<3>(meshN);
    if (order == 4)
        Run<4>(meshN);
}
